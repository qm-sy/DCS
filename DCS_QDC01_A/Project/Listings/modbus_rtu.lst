C51 COMPILER V9.60.7.0   MODBUS_RTU                                                        12/29/2025 21:49:53 PAGE 1   


C51 COMPILER V9.60.7.0, COMPILATION OF MODULE MODBUS_RTU
OBJECT MODULE PLACED IN ..\Output\modbus_rtu.obj
COMPILER INVOKED BY: D:\APP\KEIL\MDK\C51\BIN\C51.EXE ..\Emembed\Src\modbus_rtu.c LARGE OPTIMIZE(8,SPEED) BROWSE INCDIR(.
                    -.\BSP\Inc;..\Core\Inc;..\Driver;..\Emembed\Inc;..\SYSTEM\Inc) DEBUG OBJECTEXTEND PRINT(.\Listings\modbus_rtu.lst) TABS(2
                    -) OBJECT(..\Output\modbus_rtu.obj)

line level    source

   1          #include "modbus_rtu.h"
   2          
   3          MODBIS_INFO modbus;
   4          
   5          /**
   6           * @brief modbus_rtu  无奇偶校验
   7           *
   8           * @param   void
   9           *
  10           * @return  void 
  11          **/
  12          void Modbus_Event( void )
  13          {
  14   1          uint16_t crc,rccrc;
  15   1          
  16   1          /*1.接收完毕                                           */
  17   1          if( rs485.rcv_end_Flag == 1 )
  18   1          {
  19   2              /*2.CRC校验                                         */                                     
  20   2              crc = MODBUS_CRC16(rs485.rcv_buf, rs485.rcv_cnt-2);
  21   2              rccrc = (rs485.rcv_buf[rs485.rcv_cnt - 1]) | (rs485.rcv_buf[rs485.rcv_cnt -2 ] << 8);
  22   2      
  23   2              /*3.CRC校验通过，进行地址域校验                      */
  24   2              if( crc == rccrc )
  25   2              {
  26   3                  /*3-1.地址域校验通过，进入相应功能函数进行处理      */
  27   3                  if( rs485.rcv_buf[0] == SLAVE_ADDR )
  28   3                  {
  29   4                      switch ( rs485.rcv_buf[1] )
  30   4                      {
  31   5                          case FUN_03:      Modbus_Fun3();          break;
  32   5                          case FUN_04:      Modbus_Fun4();          break;
  33   5                          case FUN_06:      Modbus_Fun6();          break;
  34   5                          case FUN_16:      Modbus_Fun16();         break;
  35   5      
  36   5                          default:                                  break;
  37   5                      }
  38   4                  }
  39   3              }
  40   2              /*4.清空接收完毕标志位  清空接收计数        */    
  41   2              rs485.rcv_end_Flag = 0;
  42   2              rs485.rcv_cnt = 0; 
  43   2          }
  44   1      }
  45          
  46          /**
  47           * @brief 读输入寄存器  03
  48           *
  49           * @param   void
  50           *
  51           * @return  void 
  52          **/
  53          void Modbus_Fun3( void )
C51 COMPILER V9.60.7.0   MODBUS_RTU                                                        12/29/2025 21:49:53 PAGE 2   

  54          {
  55   1          uint16_t i;
  56   1      
  57   1          modbus.rcv_addr1_valH  = 3;                //DATA1 H 位置
  58   1          modbus.start_reg_03    = rs485.rcv_buf[2] << 8 | rs485.rcv_buf[3];
  59   1          modbus.reg_num_03      = rs485.rcv_buf[4] << 8 | rs485.rcv_buf[5];
  60   1      
  61   1          rs485.send_buf[0]  = MASTER_ADDR;                  //Addr
  62   1          rs485.send_buf[1]  = FUN_03;                   //Fun
  63   1          rs485.send_buf[2]  = modbus.reg_num_03 * 2;    //Byte Count
  64   1      
  65   1          for( i = modbus.start_reg_03; i < modbus.start_reg_03 + modbus.reg_num_03; i++ )
  66   1          {
  67   2              /*    每次循环前初始化byte_info                       */
  68   2              modbus.byte_info_H = modbus.byte_info_L = 0X00;
  69   2              switch (i)
  70   2              {   
  71   3                  /*  40001 通道查询                      */
  72   3                  case 0x00:
  73   3                      modbus.byte_info_H = 0;
  74   3                      modbus.byte_info_L = slave_06.channel_num;
  75   3                      break;
  76   3      
  77   3                  /*  40002 同步状态查询                  */    
  78   3                  case 0x01:
  79   3                      modbus.byte_info_H = 0;
  80   3                      modbus.byte_info_L = slave_06.sync_switch;
  81   3                      break;
  82   3      
  83   3                  /*  40003 风速查询                      */
  84   3                  case 0x02:    
  85   3                      modbus.byte_info_H = 0;
  86   3                      modbus.byte_info_L = slave_06.fan_level;
  87   3      
  88   3                      break;
  89   3      
  90   3                  /*  40004 功率查询                      */
  91   3                  case 0x03:    
  92   3                      modbus.byte_info_H = 0;
  93   3                      modbus.byte_info_L = slave_06.power_level;
  94   3      
  95   3                      break;
  96   3      
  97   3                  /*  40005 报警温度查询                  */
  98   3                  case 0x04:   
  99   3                      modbus.byte_info_H = 0;
 100   3                      modbus.byte_info_L = slave_06.OTP_temp1;
 101   3      
 102   3                      break;
 103   3      
 104   3                  /*  40006 模式查询                      */
 105   3                  case 0x05:   
 106   3                      modbus.byte_info_H = 0;
 107   3                      modbus.byte_info_L = slave_06.mode_num;
 108   3      
 109   3                      break;
 110   3      
 111   3                  default:
 112   3                      break;
 113   3              }
 114   2              rs485.send_buf[modbus.rcv_addr1_valH++] = modbus.byte_info_H;
 115   2              rs485.send_buf[modbus.rcv_addr1_valH++] = modbus.byte_info_L;
C51 COMPILER V9.60.7.0   MODBUS_RTU                                                        12/29/2025 21:49:53 PAGE 3   

 116   2          }
 117   1          slave_to_master(FUN_03,3 + modbus.reg_num_03 * 2);
 118   1      }
 119          
 120          /**
 121           * @brief 读输出寄存器  04
 122           *
 123           * @param   void
 124           *
 125           * @return  void 
 126          **/
 127          void Modbus_Fun4( void )
 128          {
 129   1          uint16_t i;
 130   1      
 131   1          modbus.rcv_addr1_valH  = 3;                 //DATA1 H 位置
 132   1          modbus.start_reg_04 = rs485.rcv_buf[2] << 8 | rs485.rcv_buf[3];
 133   1          modbus.reg_num_04   = rs485.rcv_buf[4] << 8 | rs485.rcv_buf[5];
 134   1      
 135   1          rs485.send_buf[0]  = MASTER_ADDR;                  //Addr
 136   1          rs485.send_buf[1]  = FUN_04;                   //Fun
 137   1          rs485.send_buf[2]  = modbus.reg_num_04 * 2;    //Byte Count
 138   1      
 139   1          for( i = modbus.start_reg_04; i < modbus.start_reg_04 + modbus.reg_num_04; i++ )
 140   1          {
 141   2              /*    每次循环前初始化byte_info                       */
 142   2              modbus.byte_info_H = modbus.byte_info_L = 0X00;
 143   2              switch (i)
 144   2              {
 145   3                  case 0x00:
 146   3                      modbus.byte_info_H = 0x00;
 147   3                      modbus.byte_info_L = power_ctrl.OTP1_alarm_flag;
 148   3      
 149   3                      break;
 150   3      
 151   3                  case 0x01:
 152   3                      modbus.byte_info_H = 0x00;
 153   3                      modbus.byte_info_L = power_ctrl.signal_flag;
 154   3      
 155   3                      break;
 156   3      
 157   3                  /*  40001   加热通道设置                */
 158   3                  case 0x02:       
 159   3                      modbus.byte_info_H = 0x00;
 160   3                      modbus.byte_info_L = slave_06.channel_num;     
 161   3                      break;
 162   3      
 163   3                  /*  40002   同步开关设置                */
 164   3                  case 0x03:
 165   3                      modbus.byte_info_H = 0x00;
 166   3                      modbus.byte_info_L = slave_06.sync_switch;   
 167   3                                           
 168   3                      break;
 169   3      
 170   3                  /*  40003   风速设置                    */
 171   3                  case 0x04: 
 172   3                      modbus.byte_info_H = 0x00;
 173   3                      modbus.byte_info_L = slave_06.fan_level;                                          
 174   3                      break;  
 175   3                      
 176   3                  /*  40004   功率档位设置                */
 177   3                  case 0x05:
C51 COMPILER V9.60.7.0   MODBUS_RTU                                                        12/29/2025 21:49:53 PAGE 4   

 178   3                      modbus.byte_info_H = 0x00;
 179   3                      modbus.byte_info_L = slave_06.power_level;                                          
 180   3                      break;
 181   3      
 182   3                  /*  40005   报警温度设置                */
 183   3                  case 0x06:
 184   3                      modbus.byte_info_H = 0x00;
 185   3                      modbus.byte_info_L = slave_06.OTP_temp1;                                          
 186   3                      break;
 187   3      
 188   3                  /*  40006   模式设置                    */
 189   3                  case 0x07:  
 190   3                      modbus.byte_info_H = 0x00;
 191   3                      modbus.byte_info_L = slave_06.mode_num;                                 
 192   3                      break;
 193   3      
 194   3                  /*  40007   总开关设置                  */
 195   3                  case 0x08: 
 196   3                      modbus.byte_info_H = 0x00;
 197   3                      modbus.byte_info_L = power_ctrl.Power_Swtich;   
 198   3                      break;
 199   3      
 200   3                  default:
 201   3                      break;
 202   3              }
 203   2              rs485.send_buf[modbus.rcv_addr1_valH++] = modbus.byte_info_H;
 204   2              rs485.send_buf[modbus.rcv_addr1_valH++] = modbus.byte_info_L;
 205   2          }
 206   1          slave_to_master(FUN_04,3 + modbus.reg_num_04 * 2);
 207   1      }
 208          
 209          /**
 210           * @brief 写单个输出寄存器  06
 211           *
 212           * @param   void
 213           *
 214           * @return  void 
 215          **/
 216          void Modbus_Fun6( void )
 217          {
 218   1          Buzzer = 0;
 219   1          modbus.reg_addr_06 = rs485.rcv_buf[2] << 8 | rs485.rcv_buf[3];
 220   1          modbus.byte_info_H = rs485.rcv_buf[4];
 221   1          modbus.byte_info_L = rs485.rcv_buf[5];
 222   1      
 223   1          switch (modbus.reg_addr_06)
 224   1          {
 225   2              /*  40001   加热通道设置                */
 226   2              case 0x00:       
 227   2                  slave_06.channel_num = modbus.byte_info_L;        
 228   2                  break;
 229   2      
 230   2              /*  40002   同步开关设置                */
 231   2              case 0x01:
 232   2                  slave_06.sync_switch = modbus.byte_info_L;                                         
 233   2                  break;
 234   2      
 235   2              /*  40003   风速设置                    */
 236   2              case 0x02:                                         
 237   2                  slave_06.fan_level = modbus.byte_info_L;
 238   2                  fan_ctrl();
 239   2                  break;  
C51 COMPILER V9.60.7.0   MODBUS_RTU                                                        12/29/2025 21:49:53 PAGE 5   

 240   2                  
 241   2              /*  40004   功率档位设置                */
 242   2              case 0x03:                                         
 243   2                  slave_06.power_level = modbus.byte_info_L;
 244   2                  power_level_crl();
 245   2                  break;
 246   2      
 247   2              /*  40005   报警温度设置                */
 248   2              case 0x04:
 249   2                  slave_06.OTP_temp1 = modbus.byte_info_L;                                         
 250   2                  break;
 251   2      
 252   2              /*  40006   模式设置                    */
 253   2              case 0x05:                                         
 254   2                  slave_06.mode_num = rs485.rcv_buf[5];
 255   2                  mode_select();
 256   2                  break;
 257   2      
 258   2              /*  40007   总开关设置                  */
 259   2              case 0x06:  
 260   2                  power_ctrl.Power_Swtich = rs485.rcv_buf[5];
 261   2                  break;
 262   2      
 263   2              default:
 264   2                  break;   
 265   2          }
 266   1          slave_to_master(FUN_06,8);
 267   1          
 268   1          eeprom_data_write();
 269   1          Buzzer = 1;
 270   1      }
 271          
 272          /**
 273           * @brief 写多个输出寄存器  16
 274           *
 275           * @param   void
 276           *
 277           * @return  void 
 278          **/
 279          void Modbus_Fun16( void )
 280          {
 281   1          uint16_t i;
 282   1      
 283   1          Buzzer = 0;
 284   1          modbus.rcv_addr1_valH = 7;                  //DATA1 H位置
 285   1          modbus.start_reg_16 = rs485.rcv_buf[2] << 8 | rs485.rcv_buf[3];
 286   1          modbus.reg_num_16   = rs485.rcv_buf[5] << 8 | rs485.rcv_buf[6];
 287   1      
 288   1          for( i = modbus.rcv_addr1_valH; i < modbus.rcv_addr1_valH + modbus.reg_num_16; i++)
 289   1          {
 290   2              modbus.byte_info_H = rs485.rcv_buf[modbus.rcv_addr1_valH];
 291   2              modbus.byte_info_L = rs485.rcv_buf[modbus.rcv_addr1_valH + 1];
 292   2              switch (i)
 293   2              {
 294   3                  /*  40001  通道设置                 */
 295   3                  case 0x00:
 296   3                      slave_06.channel_num = modbus.byte_info_L;
 297   3                      break;
 298   3                  
 299   3                  /*  40002   同步状态设置                          */
 300   3                  case 0x01:
 301   3                      slave_06.sync_switch = modbus.byte_info_L;
C51 COMPILER V9.60.7.0   MODBUS_RTU                                                        12/29/2025 21:49:53 PAGE 6   

 302   3                      break;
 303   3      
 304   3                  /*  40003 风速设置                          */
 305   3                  case 0x02:
 306   3                      slave_06.fan_level = modbus.byte_info_L;
 307   3                      fan_ctrl();
 308   3                      break;
 309   3      
 310   3                  /*  40004  功率设置                   */
 311   3                  case 0x03:
 312   3                      slave_06.power_level = modbus.byte_info_L;
 313   3                      power_level_crl();
 314   3                      break;
 315   3      
 316   3                  /*  40005  报警温度设置                   */
 317   3                  case 0x04:                                         
 318   3                      slave_06.OTP_temp1 = modbus.byte_info_L;
 319   3                      break;
 320   3      
 321   3                  /*  40006  模式设置                   */
 322   3                  case 0x05:                                         
 323   3                      slave_06.mode_num = modbus.byte_info_L;
 324   3                      mode_select();
 325   3                      break;
 326   3                      
 327   3                  default:
 328   3                      break;
 329   3              }
 330   2              modbus.rcv_addr1_valH += 2;         //从Value1_H →→ 从Value2_H
 331   2          }
 332   1      
 333   1          slave_to_master(FUN_16,8);
 334   1      
 335   1          eeprom_data_write();                      //记录更改后的值
 336   1          Buzzer = 1;
 337   1      }
 338          
 339          
 340          /**
 341           * @brief 从机回复主机
 342           *  
 343           * @param   code_num:功能码       
 344           * @param   length:数据长度        
 345           * 
 346            @return  crc16:crc校验的值 2byte
 347           */
 348          void slave_to_master(uint8_t code_num,uint8_t length)
 349          {
 350   1          uint16_t crc;
 351   1      
 352   1          switch (code_num)
 353   1          {
 354   2              case 0x03:
 355   2                  crc = MODBUS_CRC16(rs485.send_buf,length);
 356   2      
 357   2                  rs485.send_buf[length + 1] = crc;               //CRC H
 358   2                  rs485.send_buf[length]     = crc >> 8;          //CRC L
 359   2      
 360   2                  rs485.send_bytelength = length + 2;
 361   2                  
 362   2                  break;
 363   2              case 0x04:
C51 COMPILER V9.60.7.0   MODBUS_RTU                                                        12/29/2025 21:49:53 PAGE 7   

 364   2                  crc = MODBUS_CRC16(rs485.send_buf,length);
 365   2      
 366   2                  rs485.send_buf[length + 1] = crc;               //CRC H
 367   2                  rs485.send_buf[length]     = crc >> 8;          //CRC L
 368   2      
 369   2                  rs485.send_bytelength = length + 2;
 370   2                  
 371   2                  break;    
 372   2      
 373   2              case 0x06:
 374   2                  memcpy(rs485.send_buf,rs485.rcv_buf,6);
 375   2                  if( rs485.send_buf[3] == 0x05 )
 376   2                  {
 377   3                      rs485.send_buf[0] = 0x01;
 378   3                  }
 379   2      
 380   2                  crc = MODBUS_CRC16(rs485.send_buf,6);
 381   2      
 382   2                  rs485.send_buf[7] = crc;               //CRC H
 383   2                  rs485.send_buf[6]     = crc >> 8;          //CRC L
 384   2      
 385   2                  rs485.send_bytelength = 8;
 386   2                  
 387   2                  break;   
 388   2      
 389   2              case 0x10:
 390   2                  memcpy(rs485.send_buf,rs485.rcv_buf,6);
 391   2              
 392   2                  crc = MODBUS_CRC16(rs485.send_buf,6);
 393   2      
 394   2                  rs485.send_buf[7] = crc;                 //CRC H
 395   2                  rs485.send_buf[6] = crc >> 8;              //CRC L
 396   2              
 397   2                  rs485.send_bytelength = length;
 398   2                  
 399   2                  break;         
 400   2      
 401   2              default:
 402   2                  break;
 403   2          }
 404   1      
 405   1          DR_485 = 1;                                 //485可以发送
 406   1          delay_ms(2);
 407   1          S4CON |= S4TI;                              //开始发送
 408   1          delay_ms(1);
 409   1      }
 410          
 411          
 412          /**
 413           * @brief crc校验函数
 414           * 
 415           * @param   buf：  Address(1 byte) +Funtion(1 byte) ）+Data(n byte)   
 416           * @param   length:数据长度           
 417           * 
 418            @return  crc16:crc校验的值 2byte
 419           */
 420          uint16_t MODBUS_CRC16(uint8_t *buf, uint8_t length)
 421          {
 422   1        uint8_t i;
 423   1        uint16_t  crc16;
 424   1      
 425   1          /* 1, 预置16位CRC寄存器为0xffff（即全为1）                          */
C51 COMPILER V9.60.7.0   MODBUS_RTU                                                        12/29/2025 21:49:53 PAGE 8   

 426   1        crc16 = 0xffff; 
 427   1      
 428   1        do
 429   1        {
 430   2              /* 2, 把8位数据与16位CRC寄存器的低位相异或，把结果放于CRC寄存器     */    
             -    
 431   2          crc16 ^= (uint16_t)*buf;    //
 432   2          for(i=0; i<8; i++)    
 433   2          {
 434   3                  /* 3, 如果最低位为1，把CRC寄存器的内容右移一位(朝低位)，用0填补最高
             -位 再异或0xA001    */
 435   3            if(crc16 & 1)
 436   3                  {
 437   4                      crc16 = (crc16 >> 1) ^ 0xA001;
 438   4                  }
 439   3                  /* 4, 如果最低位为0，把CRC寄存器的内容右移一位(朝低位)，用0填补最高
             -位                */
 440   3                  else
 441   3                  {
 442   4                      crc16 >>= 1;
 443   4                  }   
 444   3          }
 445   2          buf++;
 446   2        }while(--length != 0);
 447   1      
 448   1        return  (crc16);
 449   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   1464    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =     17       8
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
