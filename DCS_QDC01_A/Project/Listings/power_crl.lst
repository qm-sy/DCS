C51 COMPILER V9.60.7.0   POWER_CRL                                                         12/29/2025 15:57:58 PAGE 1   


C51 COMPILER V9.60.7.0, COMPILATION OF MODULE POWER_CRL
OBJECT MODULE PLACED IN ..\Output\power_crl.obj
COMPILER INVOKED BY: D:\APP\KEIL\MDK\C51\BIN\C51.EXE ..\BSP\Src\power_crl.c LARGE OPTIMIZE(8,SPEED) BROWSE INCDIR(..\BSP
                    -\Inc;..\Core\Inc;..\Driver;..\Emembed\Inc;..\SYSTEM\Inc) DEBUG OBJECTEXTEND PRINT(.\Listings\power_crl.lst) TABS(2) OBJE
                    -CT(..\Output\power_crl.obj)

line level    source

   1          #include "power_crl.h"
   2          
   3          AC_DC ac_dc;
   4          SLAVE_06 slave_06;
   5          POWER_CTRL power_ctrl;
   6          
   7          /**
   8           * @brief 移相触发调用结构体初始化
   9           *
  10           * @param   
  11           *
  12           * @return  void
  13          **/
  14          void Power_Statu_Init( void )
  15          {
  16   1          power_ctrl.zero_flag = 0;
  17   1          temp.temp_scan_flag  = 0;
  18   1          FAN_TMEP = 0;
  19   1          Buzzer = BUZZER_OFF;
  20   1          power_ctrl.Power_Swtich = 0;
  21   1          power_ctrl.AC1_enable = power_ctrl.AC2_enable = power_ctrl.AC3_enable = DISABLE; 
  22   1          power_ctrl.FAN_enable = DISABLE;
  23   1          power_ctrl.time_delay = 61700;
  24   1      }
  25          
  26          /**
  27           * @brief 外部中断0中断处理函数
  28           *
  29           * @param   
  30           *
  31           * @return  void
  32          **/
  33          void INT0_ISR( void ) interrupt 0
  34          {
  35   1          /* 1, 检测到外部中断后，等待THL\TLI后触发TIM1中断       */
  36   1          TL1 = power_ctrl.time_delay;        
  37   1        TH1 = power_ctrl.time_delay >> 8;       
  38   1      
  39   1          power_ctrl.zero_flag = 1;
  40   1      
  41   1          /* 2, 定时器1开始计时，打开TIM1中断                     */
  42   1          TR1 = 1;             
  43   1          ET1 = 1; 
  44   1      }
  45          
  46          /**
  47           * @brief Timer1中断处理函数
  48           *
  49           * @param   
  50           *
  51           * @return  void
  52          **/
  53          void Tim1_ISR( void ) interrupt 3   //10ms
C51 COMPILER V9.60.7.0   POWER_CRL                                                         12/29/2025 15:57:58 PAGE 2   

  54          {
  55   1          /* 1, 中断触发后，power_ch电平 由高电平变为低电平           */
  56   1          if( power_ctrl.zero_flag == 1 )
  57   1          {
  58   2              power_ctrl.zero_flag = 0;
  59   2      
  60   2               /* 2, 温度允许，使能为1时可开启输出          */
  61   2              AC_Out1 = 1 - power_ctrl.AC1_enable;
  62   2              AC_Out2 = 1 - power_ctrl.AC2_enable;
  63   2              AC_Out3 = 1 - power_ctrl.AC3_enable;
  64   2      
  65   2               /* 3, 设置下一次Timer1中断触发所需时间，即脉冲时间       */
  66   2              TL1 = 0xF7;       
  67   2              TH1 = 0xFF;       
  68   2          }else
  69   1          {
  70   2              /* 2, 下一次进入Timer1中断，power_ch电平 由低电平变为高电平，完成一次10us
             -冲，即斩波*/
  71   2              AC_Out1 = AC_Out2 = AC_Out3 = 1;
  72   2      
  73   2              /* 3, 定时器1停止计时，关闭TIM1中断，等待下一次外部中断     */
  74   2              TR1 = 0;            
  75   2              ET1 = 0; 
  76   2          }
  77   1      }
  78          
  79          /**
  80           * @brief 220V输出功率控制函数 
  81           *
  82           * @param   power_level：输出功率百分比  0%~100%
  83           *
  84           * @return  void
  85          **/
  86          void power_level_crl( void )
  87          {
  88   1          power_ctrl.time_delay = 58000 + 74 * slave_06.power_level;
  89   1      }
  90          
  91          
  92          /**
  93           * @brief 24V PWM风扇档位控制函数
  94           *
  95           * @param   level :风扇档位 0~6档
  96           *
  97           * @return  void
  98          **/
  99          void fan_ctrl( void )
 100          {
 101   1          PWMB_CCR7 = PWMB_CCR8 = slave_06.fan_level * 184;
 102   1      }
 103          
 104          /**
 105           * @brief 温度扫描，DHT11温湿度扫描 1s/次 控制220V输出使能
 106           *
 107           * @param[in] 
 108           * 
 109           * @return  
 110           * 
 111          **/
 112          void temp_scan( void )
 113          {
 114   1          if( temp.temp_scan_flag == 1 )
C51 COMPILER V9.60.7.0   POWER_CRL                                                         12/29/2025 15:57:58 PAGE 3   

 115   1          {
 116   2              temp.NTC1_value =  get_temp(NTC);
 117   2      
 118   2              if( temp.NTC1_value >= FAN_START_TEMP )      //小风扇启动温度
 119   2              {
 120   3                  FAN_TMEP = 1;
 121   3              }else
 122   2              {
 123   3                  FAN_TMEP = 0;
 124   3              }
 125   2      
 126   2              if( temp.NTC1_value >= power_ctrl.OTP_temp2 )    //过温保护2  蜂鸣器报警 滴-滴-滴-滴
             -
 127   2              {
 128   3                  power_ctrl.OTP2_alarm_flag = 1;
 129   3                  power_ctrl.OTP1_alarm_flag = 0;
 130   3              }
 131   2              if( temp.NTC1_value < (power_ctrl.OTP_temp2 - 5) )
 132   2              {
 133   3                  power_ctrl.OTP2_alarm_flag = 0;
 134   3      
 135   3                  if( temp.NTC1_value >= slave_06.OTP_temp1 )    //过温保护1  蜂鸣器报警 滴-滴
 136   3                  {
 137   4                      power_ctrl.OTP1_alarm_flag = 1;
 138   4                  }
 139   3                  if( temp.NTC1_value < (slave_06.OTP_temp1 - 2))
 140   3                  {
 141   4                      power_ctrl.OTP1_alarm_flag = 0;
 142   4                      Buzzer = BUZZER_OFF;
 143   4                  }
 144   3              }
 145   2      
 146   2              temp.temp_scan_flag = 0;
 147   2          }
 148   1      }
 149          
 150          void mode_select( void )
 151          {
 152   1          eeprom_mode_write();
 153   1          eeprom_data_read();
 154   1          eeprom_data_init();
 155   1      }
 156          
 157          void fan_delay_ctrl( void )
 158          {
 159   1          static uint8_t signal_flag = 0;
 160   1      
 161   1          if( signal_flag != power_ctrl.signal_flag )
 162   1          {
 163   2              signal_flag = power_ctrl.signal_flag;
 164   2      
 165   2              power_ctrl.fan_delay_flag = (( slave_06.sync_switch == 1 ) && ( signal_flag == 0 )) ? 1 : 0;
 166   2          }
 167   1      }              
 168          
 169          /**
 170           * @brief AC DC输出使能控制
 171           *
 172           * @param[in] 
 173           * 
 174           * @return  
 175           * 
C51 COMPILER V9.60.7.0   POWER_CRL                                                         12/29/2025 15:57:58 PAGE 4   

 176          **/
 177          void ac_dc_ctrl( void )
 178          {
 179   1          if( power_ctrl.Power_Swtich == 1 )
 180   1          {
 181   2              power_ctrl.AC1_enable = (ACout_enable_judge() & (slave_06.channel_num & 0x01))? ENABLE : DISABLE; 
             -        // 根据函数返回值设置使能状态
 182   2              power_ctrl.AC2_enable = (ACout_enable_judge() & (slave_06.channel_num & 0x02))? ENABLE : DISABLE; 
             -        // 根据函数返回值设置使能状态
 183   2              power_ctrl.AC3_enable = (ACout_enable_judge() & (slave_06.channel_num & 0x04))? ENABLE : DISABLE; 
             -        // 根据函数返回值设置使能状态
 184   2      
 185   2              power_ctrl.FAN_enable = (slave_06.sync_switch      == 0 ||    //同步关闭
 186   2                                       power_ctrl.signal_flag    == 1 ||    //有24V信号进来
 187   2                                       power_ctrl.fan_delay_flag == 1)      //风扇延时输出信号
 188   2                                       ? ENABLE : DISABLE;
 189   2          }
 190   1          else
 191   1          {
 192   2              power_ctrl.AC1_enable = power_ctrl.AC2_enable = power_ctrl.AC3_enable = power_ctrl.FAN_enable = DI
             -SABLE;
 193   2          }
 194   1          
 195   1          PWMB_BKR = (power_ctrl.FAN_enable == ENABLE) ? 0x80 : 0x00;
 196   1      }
 197          
 198          
 199          /**
 200           * @brief AC输出使能判断
 201           *
 202           * @param[in]
 203           * 
 204           * @return  
 205           * 
 206          **/
 207          uint8_t ACout_enable_judge( void )                 
 208          {
 209   1          // 第1层检查：过温保护2
 210   1          // 如果温度超过过温保护阈值，立即返回 0（不加热）
 211   1          if ( temp.NTC1_value >= power_ctrl.OTP_temp2 ) 
 212   1          {
 213   2              return DISABLE;
 214   2          }
 215   1      
 216   1          // 第2层检查：功率是否为0
 217   1          if( slave_06.power_level == 0 )
 218   1          {
 219   2              return DISABLE;
 220   2          }
 221   1          
 222   1          // 第3层检查：工作模式
 223   1          if ( slave_06.sync_switch == SW_OPEN ) 
 224   1          {  
 225   2              if ( power_ctrl.signal_flag == 0 )         // 同步模式且无信号时，只有在预加热状
             -下才允许加热
 226   2              {
 227   3                  return DISABLE;
 228   3              }
 229   2          }
 230   1          
 231   1          // 其他情况：允许加热
 232   1          return ENABLE;
C51 COMPILER V9.60.7.0   POWER_CRL                                                         12/29/2025 15:57:58 PAGE 5   

 233   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    577    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =     30    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
