C51 COMPILER V9.60.7.0   MODBUS_RTU                                                        12/29/2025 16:19:13 PAGE 1   


C51 COMPILER V9.60.7.0, COMPILATION OF MODULE MODBUS_RTU
OBJECT MODULE PLACED IN ..\Output\modbus_rtu.obj
COMPILER INVOKED BY: D:\APP\KEIL\MDK\C51\BIN\C51.EXE ..\Emembed\Src\modbus_rtu.c LARGE OPTIMIZE(8,SPEED) BROWSE INCDIR(.
                    -.\Driver;..\SYSTEM\Inc;..\BSP\Inc;..\Core\Inc;..\Emembed\Inc) DEBUG OBJECTEXTEND PRINT(.\Listings\modbus_rtu.lst) TABS(2
                    -) OBJECT(..\Output\modbus_rtu.obj)

line level    source

   1          #include "modbus_rtu.h"
   2          
   3          MODBIS_INFO modbus;
   4          
   5          /**
   6           * @brief modbus_rtu  无奇偶校验
   7           *
   8           * @param   void
   9           *
  10           * @return  void 
  11          **/
  12          void Modbus_Event( void )
  13          {
  14   1          uint16_t crc,rccrc;
  15   1          
  16   1          /*1.接收完毕                                           */
  17   1          if( rs485.rcv_end_Flag == 1 )
  18   1          {
  19   2              /*2.CRC校验                                         */                                     
  20   2              crc = MODBUS_CRC16(rs485.rcv_buf, rs485.rcv_cnt-2);
  21   2              rccrc = (rs485.rcv_buf[rs485.rcv_cnt - 1]) | (rs485.rcv_buf[rs485.rcv_cnt -2 ] << 8);
  22   2      
  23   2              /*3.CRC校验通过，进行地址域校验                      */
  24   2              if( crc == rccrc )
  25   2              {
  26   3                  /*3-1.地址域校验通过，进入相应功能函数进行处理      */
  27   3                  if( rs485.rcv_buf[0] == SLAVE_ADDR )
  28   3                  {
  29   4                      switch ( rs485.rcv_buf[1] )
  30   4                      {
  31   5                          case FUN_03:      Modbus_Fun3();          break;
  32   5                          case FUN_04:      Modbus_Fun4();          break;
  33   5                          case FUN_06:      Modbus_Fun6();          break;
  34   5      
  35   5                          default:                                  break;
  36   5                      }
  37   4                  }
  38   3              }
  39   2              /*4.清空接收完毕标志位  清空接收计数        */    
  40   2              rs485.rcv_end_Flag = 0;
  41   2              rs485.rcv_cnt = 0; 
  42   2          }
  43   1      }
  44          
  45          void modbus_params_init( void )
  46          {
  47   1          modbus.modbus_04_rcv_over = 1;
  48   1          modbus.scan_flag_04 = 0;
  49   1          modbus.scan_flag_04_allow = 0;
  50   1      }
  51          
  52          void Modbus_Fun3()
  53          {
C51 COMPILER V9.60.7.0   MODBUS_RTU                                                        12/29/2025 16:19:13 PAGE 2   

  54   1          uint16_t i;
  55   1      
  56   1          modbus.rcv_addr1_valH = 3;                  //DATA1_H 位置 rcvbuf[3]
  57   1      
  58   1          for( i = modbus.start_reg_03; i < modbus.start_reg_03 + modbus.reg_num_03; i++)
  59   1          {
  60   2              modbus.byte_info_H = rs485.rcv_buf[modbus.rcv_addr1_valH];
  61   2              modbus.byte_info_L = rs485.rcv_buf[modbus.rcv_addr1_valH + 1];
  62   2      
  63   2              switch (i)
  64   2              {
  65   3                  /*  40001 通道查询                      */
  66   3                  case 0x00:
  67   3                      lcd_info.channel_num = modbus.byte_info_L;
  68   3                      break;
  69   3      
  70   3                  /*  40002 同步状态查询                  */        
  71   3                  case 0x01:
  72   3                      lcd_info.sync_switch = modbus.byte_info_L;
  73   3                      break;
  74   3          
  75   3                  /*  40003 风速查询                      */    
  76   3                  case 0x02:
  77   3                      lcd_info.fan_level = modbus.byte_info_L;
  78   3      
  79   3                      break; 
  80   3      
  81   3                  /*  40004 功率查询                      */
  82   3                  case 0x03:
  83   3                      lcd_info.power_level = modbus.byte_info_L;
  84   3      
  85   3                      break;
  86   3          
  87   3                  /*  40005 报警温度查询                  */    
  88   3                  case 0x04:
  89   3                      lcd_info.OTP_temp1 = modbus.byte_info_L;
  90   3                      break;  
  91   3      
  92   3                  /*  40006 模式查询                      */
  93   3                  case 0x05:
  94   3                      lcd_info.mode_num = modbus.byte_info_L;
  95   3                      break;   
  96   3          
  97   3                  default:
  98   3                      break;
  99   3              }
 100   2              modbus.rcv_addr1_valH += 2;
 101   2          }
 102   1          lcd_info.lcd_connect_flag = 1;
 103   1      
 104   1        screen_all_dis();
 105   1      }
 106          
 107          
 108          void Modbus_Fun4()
 109          {
 110   1          uint16_t i;
 111   1      
 112   1          modbus.rcv_addr1_valH = 3;              //DATA1_H 位置 rcvbuf[3]
 113   1      
 114   1          for(i = modbus.start_reg_04; i < modbus.start_reg_04 + modbus.reg_num_04; i++)
 115   1          {
C51 COMPILER V9.60.7.0   MODBUS_RTU                                                        12/29/2025 16:19:13 PAGE 3   

 116   2              modbus.byte_info_H = rs485.rcv_buf[modbus.rcv_addr1_valH];
 117   2              modbus.byte_info_L = rs485.rcv_buf[modbus.rcv_addr1_valH + 1];
 118   2              switch (i)
 119   2              {
 120   3                  case 0:
 121   3                      lcd_info.OTP1_alarm_flag = modbus.byte_info_L;
 122   3                      alarm_dis(lcd_info.OTP1_alarm_flag);
 123   3      
 124   3                      break;
 125   3      
 126   3                  case 1:
 127   3                      lcd_info.signal_in = modbus.byte_info_L;
 128   3                      break;
 129   3      
 130   3                  default:
 131   3                      break;
 132   3              }
 133   2              modbus.rcv_addr1_valH += 2;
 134   2          }
 135   1          modbus.modbus_04_rcv_over = 0;
 136   1      }
 137          
 138          
 139          void Modbus_Fun6( void )
 140          {
 141   1          modbus.rcv_addr1_valH = 4;
 142   1          modbus.byte_info_H = rs485.rcv_buf[modbus.rcv_addr1_valH];
 143   1          modbus.byte_info_L = rs485.rcv_buf[modbus.rcv_addr1_valH + 1];
 144   1      
 145   1          switch (modbus.reg_addr_06)
 146   1          {
 147   2              case 5:
 148   2              delay_ms(200); 
 149   2              read_slave_03();
 150   2              break;
 151   2          }
 152   1      
 153   1      }
 154          
 155          /**
 156           * @brief crc校验函数
 157           * 
 158           * @param   buf：  Address(1 byte) +Funtion(1 byte) ）+Data(n byte)   
 159           * @param   length:数据长度           
 160           * 
 161            @return  crc16:crc校验的值 2byte
 162           */
 163          uint16_t MODBUS_CRC16(uint8_t *buf, uint8_t length)
 164          {
 165   1        uint8_t i;
 166   1        uint16_t  crc16;
 167   1      
 168   1          /* 1, 预置16位CRC寄存器为0xffff（即全为1）                          */
 169   1        crc16 = 0xffff; 
 170   1      
 171   1        do
 172   1        {
 173   2              /* 2, 把8位数据与16位CRC寄存器的低位相异或，把结果放于CRC寄存器     */    
             -    
 174   2          crc16 ^= (uint16_t)*buf;    //
 175   2          for(i=0; i<8; i++)    
 176   2          {
C51 COMPILER V9.60.7.0   MODBUS_RTU                                                        12/29/2025 16:19:13 PAGE 4   

 177   3                  /* 3, 如果最低位为1，把CRC寄存器的内容右移一位(朝低位)，用0填补最高
             -位 再异或0xA001    */
 178   3            if(crc16 & 1)
 179   3                  {
 180   4                      crc16 = (crc16 >> 1) ^ 0xA001;
 181   4                  }
 182   3                  /* 4, 如果最低位为0，把CRC寄存器的内容右移一位(朝低位)，用0填补最高
             -位                */
 183   3                  else
 184   3                  {
 185   4                      crc16 >>= 1;
 186   4                  }   
 187   3          }
 188   2          buf++;
 189   2        }while(--length != 0);
 190   1      
 191   1        return  (crc16);
 192   1      }
 193          
 194          void get_slave_status( void )
 195          {
 196   1          if(( modbus.scan_flag_04 == 1) && ( modbus.scan_flag_04_allow == 1 ))
 197   1          {
 198   2              read_slave_04();
 199   2              modbus.scan_flag_04 = 0;
 200   2          }
 201   1      }
 202          
 203          /**
 204           * @brief 读输出寄存器-03
 205           *
 206           * @param   void
 207           *
 208           * @return  void
 209           */
 210          void read_slave_03( void )
 211          {
 212   1          uint8_t send_buf[8];
 213   1          uint16_t crc;
 214   1      
 215   1          modbus.start_reg_03 = START_REG_03;
 216   1          modbus.reg_num_03   = REG_NUM_03;
 217   1      
 218   1      
 219   1          send_buf[0] = SLAVE_ADDR;       //Addr
 220   1          send_buf[1] = FUN_03;           //Fun
 221   1      
 222   1          /*   Value_H  && Value_L    */
 223   1          send_buf[2] = modbus.start_reg_03 >> 8;
 224   1          send_buf[3] = modbus.start_reg_03;
 225   1          send_buf[4] = modbus.reg_num_03 >> 8;
 226   1          send_buf[5] = modbus.reg_num_03;
 227   1      
 228   1          /*   crc    */
 229   1          crc = MODBUS_CRC16(send_buf,6);
 230   1          send_buf[6] = crc >> 8;
 231   1          send_buf[7] = crc;
 232   1      
 233   1          /*   发送，后使能接收    */
 234   1          memcpy(rs485.send_buf,send_buf,8);
 235   1          
 236   1          rs485.send_bytelength = 8;
C51 COMPILER V9.60.7.0   MODBUS_RTU                                                        12/29/2025 16:19:13 PAGE 5   

 237   1          DR_485 = 1;                                 //485可以发送
 238   1          delay_ms(2);
 239   1          S4CON |= S4TI;                              //开始发送
 240   1          delay_ms(1);
 241   1      }
 242          
 243          /**
 244           * @brief 读输入寄存器-04
 245           *
 246           * @param   void
 247           *
 248           * @return  void
 249           */
 250          void read_slave_04( void )
 251          {
 252   1          uint8_t send_buf[8];
 253   1          uint16_t crc;
 254   1      
 255   1          modbus.start_reg_04 = START_REG_04;
 256   1          modbus.reg_num_04   = REG_NUM_04;
 257   1      
 258   1          send_buf[0] = SLAVE_ADDR;       //Addr
 259   1          send_buf[1] = FUN_04;           //Fun
 260   1      
 261   1          /*   Value_H  && Value_L    */
 262   1          send_buf[2] = modbus.start_reg_04 >> 8;
 263   1          send_buf[3] = modbus.start_reg_04;
 264   1          send_buf[4] = modbus.reg_num_04 >> 8;
 265   1          send_buf[5] = modbus.reg_num_04;
 266   1      
 267   1          /*   crc    */
 268   1          crc = MODBUS_CRC16(send_buf,6);
 269   1          send_buf[6] = crc >> 8;
 270   1          send_buf[7] = crc;
 271   1      
 272   1          
 273   1          /*   发送，后使能接收    */
 274   1          memcpy(rs485.send_buf,send_buf,8);
 275   1          
 276   1          rs485.send_bytelength = 8;
 277   1          DR_485 = 1;                                 //485可以发送
 278   1          delay_ms(2);
 279   1          S4CON |= S4TI;                              //开始发送
 280   1          delay_ms(1);
 281   1      }
 282          
 283          /**
 284           * @brief 写单个输出寄存器-06
 285           *
 286           * @param   reg_addr：要写的寄存器地址
 287           *          reg_val： 要写的值
 288           *
 289           * @return  void
 290           */
 291          void write_slave_06( uint16_t reg_addr, uint8_t reg_val_H, uint8_t reg_val_L)
 292          {
 293   1          uint8_t send_buf[8];
 294   1          uint16_t crc;
 295   1      
 296   1          while ( modbus.modbus_04_rcv_over == 0 );
 297   1      
 298   1          modbus.reg_addr_06 = reg_addr;
C51 COMPILER V9.60.7.0   MODBUS_RTU                                                        12/29/2025 16:19:13 PAGE 6   

 299   1      
 300   1          send_buf[0] = SLAVE_ADDR;       //Addr
 301   1          send_buf[1] = FUN_06;           //Fun
 302   1      
 303   1          /*   Value_H  && Value_L    */
 304   1          send_buf[2] = modbus.reg_addr_06 >> 8;
 305   1          send_buf[3] = modbus.reg_addr_06;
 306   1          send_buf[4] = reg_val_H;
 307   1          send_buf[5] = reg_val_L;
 308   1      
 309   1          /*   crc    */
 310   1          crc = MODBUS_CRC16(send_buf,6);
 311   1          send_buf[6] = crc >> 8;
 312   1          send_buf[7] = crc;
 313   1      
 314   1          /*   发送，后使能接收    */
 315   1          memcpy(rs485.send_buf,send_buf,8);
 316   1      
 317   1          rs485.send_bytelength = 8;
 318   1          DR_485 = 1;                                 //485可以发送
 319   1          delay_ms(2);
 320   1          S4CON |= S4TI;                              //开始发送
 321   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    996    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =     20      31
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
