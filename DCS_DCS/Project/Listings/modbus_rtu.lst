C51 COMPILER V9.60.7.0   MODBUS_RTU                                                        12/29/2025 21:49:48 PAGE 1   


C51 COMPILER V9.60.7.0, COMPILATION OF MODULE MODBUS_RTU
OBJECT MODULE PLACED IN ..\Output\modbus_rtu.obj
COMPILER INVOKED BY: D:\APP\KEIL\MDK\C51\BIN\C51.EXE ..\Emembed\Src\modbus_rtu.c LARGE OPTIMIZE(8,SPEED) BROWSE INCDIR(.
                    -.\Driver;..\SYSTEM\Inc;..\BSP\Inc;..\Core\Inc;..\Emembed\Inc) DEBUG OBJECTEXTEND PRINT(.\Listings\modbus_rtu.lst) TABS(2
                    -) OBJECT(..\Output\modbus_rtu.obj)

line level    source

   1          #include "modbus_rtu.h"
   2          
   3          MODBIS_INFO modbus;
   4          
   5          /**
   6           * @brief modbus_rtu  无奇偶校验
   7           *
   8           * @param   void
   9           *
  10           * @return  void 
  11          **/
  12          void Modbus_Event( void )
  13          {
  14   1          uint16_t crc,rccrc;
  15   1          
  16   1          /*1.接收完毕                                           */
  17   1          if( rs485.rcv_end_Flag == 1 )
  18   1          {
  19   2              /*2.CRC校验                                         */                                     
  20   2              crc = MODBUS_CRC16(rs485.rcv_buf, rs485.rcv_cnt-2);
  21   2              rccrc = (rs485.rcv_buf[rs485.rcv_cnt - 1]) | (rs485.rcv_buf[rs485.rcv_cnt -2 ] << 8);
  22   2      
  23   2              /*3.CRC校验通过，进行地址域校验                      */
  24   2              if( crc == rccrc )
  25   2              {
  26   3                  /*3-1.地址域校验通过，进入相应功能函数进行处理      */
  27   3                  if( rs485.rcv_buf[0] == MASTER_ADDR )
  28   3                  {
  29   4                      switch ( rs485.rcv_buf[1] )
  30   4                      {
  31   5                          case FUN_03:      Modbus_Fun3();          break;
  32   5                          case FUN_04:      Modbus_Fun4();          break;
  33   5                          case FUN_06:      Modbus_Fun6();          break;
  34   5      
  35   5                          default:                                  break;
  36   5                      }
  37   4                  }
  38   3              }
  39   2              /*4.清空接收完毕标志位  清空接收计数        */    
  40   2              rs485.rcv_end_Flag = 0;
  41   2              rs485.rcv_cnt = 0; 
  42   2          }
  43   1      }
  44          
  45          void modbus_params_init( void )
  46          {
  47   1          modbus.modbus_04_rcv_over = 1;
  48   1          modbus.scan_flag_04 = 0;
  49   1          modbus.scan_flag_04_allow = 0;
  50   1      }
  51          
  52          void Modbus_Fun3()
  53          {
C51 COMPILER V9.60.7.0   MODBUS_RTU                                                        12/29/2025 21:49:48 PAGE 2   

  54   1          uint16_t i;
  55   1      
  56   1          modbus.rcv_addr1_valH = 3;                  //DATA1_H 位置 rcvbuf[3]
  57   1      
  58   1          for( i = modbus.start_reg_03; i < modbus.start_reg_03 + modbus.reg_num_03; i++)
  59   1          {
  60   2              modbus.byte_info_H = rs485.rcv_buf[modbus.rcv_addr1_valH];
  61   2              modbus.byte_info_L = rs485.rcv_buf[modbus.rcv_addr1_valH + 1];
  62   2      
  63   2              switch (i)
  64   2              {
  65   3                  /*  40001 通道查询                      */
  66   3                  case 0x00:
  67   3                      lcd_info.channel_num = modbus.byte_info_L;
  68   3                      break;
  69   3      
  70   3                  /*  40002 同步状态查询                  */        
  71   3                  case 0x01:
  72   3                      lcd_info.sync_switch = modbus.byte_info_L;
  73   3                      break;
  74   3          
  75   3                  /*  40003 风速查询                      */    
  76   3                  case 0x02:
  77   3                      lcd_info.fan_level = modbus.byte_info_L;
  78   3      
  79   3                      break; 
  80   3      
  81   3                  /*  40004 功率查询                      */
  82   3                  case 0x03:
  83   3                      lcd_info.power_level = modbus.byte_info_L;
  84   3      
  85   3                      break;
  86   3          
  87   3                  /*  40005 报警温度查询                  */    
  88   3                  case 0x04:
  89   3                      lcd_info.OTP_temp1 = modbus.byte_info_L;
  90   3                      break;  
  91   3      
  92   3                  /*  40006 模式查询                      */
  93   3                  case 0x05:
  94   3                      lcd_info.mode_num = modbus.byte_info_L;
  95   3                      break;   
  96   3          
  97   3                  default:
  98   3                      break;
  99   3              }
 100   2              modbus.rcv_addr1_valH += 2;
 101   2          }
 102   1          lcd_info.lcd_connect_flag = 1;
 103   1      
 104   1        screen_all_dis();
 105   1      }
 106          
 107          
 108          void Modbus_Fun4()
 109          {
 110   1          uint16_t i;
 111   1      
 112   1          modbus.rcv_addr1_valH = 3;              //DATA1_H 位置 rcvbuf[3]
 113   1      
 114   1          for(i = modbus.start_reg_04; i < modbus.start_reg_04 + modbus.reg_num_04; i++)
 115   1          {
C51 COMPILER V9.60.7.0   MODBUS_RTU                                                        12/29/2025 21:49:48 PAGE 3   

 116   2              modbus.byte_info_H = rs485.rcv_buf[modbus.rcv_addr1_valH];
 117   2              modbus.byte_info_L = rs485.rcv_buf[modbus.rcv_addr1_valH + 1];
 118   2              switch (i)
 119   2              {
 120   3                  case 0X00:
 121   3                      lcd_info.OTP1_alarm_flag = modbus.byte_info_L;
 122   3                      alarm_dis(lcd_info.OTP1_alarm_flag);
 123   3      
 124   3                      break;
 125   3      
 126   3                  case 0X01:
 127   3                      lcd_info.signal_in = modbus.byte_info_L;
 128   3                      break;
 129   3      
 130   3                  /*  40001 通道查询                      */
 131   3                  case 0x02:
 132   3                      lcd_info.channel_num = modbus.byte_info_L;
 133   3                      break;
 134   3      
 135   3                  /*  40002 同步状态查询                  */        
 136   3                  case 0x03:
 137   3                      lcd_info.sync_switch = modbus.byte_info_L;
 138   3                      break;
 139   3          
 140   3                  /*  40003 风速查询                      */    
 141   3                  case 0x04:
 142   3                      lcd_info.fan_level = modbus.byte_info_L;
 143   3      
 144   3                      break; 
 145   3      
 146   3                  /*  40004 功率查询                      */
 147   3                  case 0x05:
 148   3                      lcd_info.power_level = modbus.byte_info_L;
 149   3      
 150   3                      break;
 151   3          
 152   3                  /*  40005 报警温度查询                  */    
 153   3                  case 0x06:
 154   3                      lcd_info.OTP_temp1 = modbus.byte_info_L;
 155   3                      break;  
 156   3      
 157   3                  /*  40006 模式查询                      */
 158   3                  case 0x07:
 159   3                      lcd_info.mode_num = modbus.byte_info_L;
 160   3                      break; 
 161   3      
 162   3                  case 0x08:
 163   3                      lcd_info.Power_Swtich = modbus.byte_info_L;
 164   3                      break; 
 165   3      
 166   3                  default:
 167   3                      break;
 168   3              }
 169   2              modbus.rcv_addr1_valH += 2;
 170   2          }
 171   1          modbus.modbus_04_rcv_over = 0;
 172   1          screen_all_dis();
 173   1      }
 174          
 175          
 176          void Modbus_Fun6( void )
 177          {
C51 COMPILER V9.60.7.0   MODBUS_RTU                                                        12/29/2025 21:49:48 PAGE 4   

 178   1          modbus.rcv_addr1_valH = 4;
 179   1          modbus.byte_info_H = rs485.rcv_buf[modbus.rcv_addr1_valH];
 180   1          modbus.byte_info_L = rs485.rcv_buf[modbus.rcv_addr1_valH + 1];
 181   1      
 182   1          switch (modbus.reg_addr_06)
 183   1          {
 184   2              case 0X05:
 185   2              delay_ms(200); 
 186   2              read_slave_03();
 187   2              break;
 188   2          }
 189   1      }
 190          
 191          /**
 192           * @brief crc校验函数
 193           * 
 194           * @param   buf：  Address(1 byte) +Funtion(1 byte) ）+Data(n byte)   
 195           * @param   length:数据长度           
 196           * 
 197            @return  crc16:crc校验的值 2byte
 198           */
 199          uint16_t MODBUS_CRC16(uint8_t *buf, uint8_t length)
 200          {
 201   1        uint8_t i;
 202   1        uint16_t  crc16;
 203   1      
 204   1          /* 1, 预置16位CRC寄存器为0xffff（即全为1）                          */
 205   1        crc16 = 0xffff; 
 206   1      
 207   1        do
 208   1        {
 209   2              /* 2, 把8位数据与16位CRC寄存器的低位相异或，把结果放于CRC寄存器     */    
             -    
 210   2          crc16 ^= (uint16_t)*buf;    //
 211   2          for(i=0; i<8; i++)    
 212   2          {
 213   3                  /* 3, 如果最低位为1，把CRC寄存器的内容右移一位(朝低位)，用0填补最高
             -位 再异或0xA001    */
 214   3            if(crc16 & 1)
 215   3                  {
 216   4                      crc16 = (crc16 >> 1) ^ 0xA001;
 217   4                  }
 218   3                  /* 4, 如果最低位为0，把CRC寄存器的内容右移一位(朝低位)，用0填补最高
             -位                */
 219   3                  else
 220   3                  {
 221   4                      crc16 >>= 1;
 222   4                  }   
 223   3          }
 224   2          buf++;
 225   2        }while(--length != 0);
 226   1      
 227   1        return  (crc16);
 228   1      }
 229          
 230          void get_slave_status( void )
 231          {
 232   1          if(( modbus.scan_flag_04 == 1) && ( modbus.scan_flag_04_allow == 1 ))
 233   1          {
 234   2              read_slave_04();
 235   2              modbus.scan_flag_04 = 0;
 236   2          }
C51 COMPILER V9.60.7.0   MODBUS_RTU                                                        12/29/2025 21:49:48 PAGE 5   

 237   1      }
 238          
 239          /**
 240           * @brief 读输出寄存器-03
 241           *
 242           * @param   void
 243           *
 244           * @return  void
 245           */
 246          void read_slave_03( void )
 247          {
 248   1          uint8_t send_buf[8];
 249   1          uint16_t crc;
 250   1      
 251   1          modbus.start_reg_03 = START_REG_03;
 252   1          modbus.reg_num_03   = REG_NUM_03;
 253   1      
 254   1      
 255   1          send_buf[0] = SLAVE_ADDR;       //Addr
 256   1          send_buf[1] = FUN_03;           //Fun
 257   1      
 258   1          /*   Value_H  && Value_L    */
 259   1          send_buf[2] = modbus.start_reg_03 >> 8;
 260   1          send_buf[3] = modbus.start_reg_03;
 261   1          send_buf[4] = modbus.reg_num_03 >> 8;
 262   1          send_buf[5] = modbus.reg_num_03;
 263   1      
 264   1          /*   crc    */
 265   1          crc = MODBUS_CRC16(send_buf,6);
 266   1          send_buf[6] = crc >> 8;
 267   1          send_buf[7] = crc;
 268   1      
 269   1          /*   发送，后使能接收    */
 270   1          memcpy(rs485.send_buf,send_buf,8);
 271   1          
 272   1          rs485.send_bytelength = 8;
 273   1          DR_485 = 1;                                 //485可以发送
 274   1          delay_ms(2);
 275   1          S4CON |= S4TI;                              //开始发送
 276   1          delay_ms(1);
 277   1      }
 278          
 279          /**
 280           * @brief 读输入寄存器-04
 281           *
 282           * @param   void
 283           *
 284           * @return  void
 285           */
 286          void read_slave_04( void )
 287          {
 288   1          uint8_t send_buf[8];
 289   1          uint16_t crc;
 290   1      
 291   1          modbus.start_reg_04 = START_REG_04;
 292   1          modbus.reg_num_04   = REG_NUM_04;
 293   1      
 294   1          send_buf[0] = SLAVE_ADDR;       //Addr
 295   1          send_buf[1] = FUN_04;           //Fun
 296   1      
 297   1          /*   Value_H  && Value_L    */
 298   1          send_buf[2] = modbus.start_reg_04 >> 8;
C51 COMPILER V9.60.7.0   MODBUS_RTU                                                        12/29/2025 21:49:48 PAGE 6   

 299   1          send_buf[3] = modbus.start_reg_04;
 300   1          send_buf[4] = modbus.reg_num_04 >> 8;
 301   1          send_buf[5] = modbus.reg_num_04;
 302   1      
 303   1          /*   crc    */
 304   1          crc = MODBUS_CRC16(send_buf,6);
 305   1          send_buf[6] = crc >> 8;
 306   1          send_buf[7] = crc;
 307   1      
 308   1          
 309   1          /*   发送，后使能接收    */
 310   1          memcpy(rs485.send_buf,send_buf,8);
 311   1          
 312   1          rs485.send_bytelength = 8;
 313   1          DR_485 = 1;                                 //485可以发送
 314   1          delay_ms(2);
 315   1          S4CON |= S4TI;                              //开始发送
 316   1          delay_ms(1);
 317   1      }
 318          
 319          /**
 320           * @brief 写单个输出寄存器-06
 321           *
 322           * @param   reg_addr：要写的寄存器地址
 323           *          reg_val： 要写的值
 324           *
 325           * @return  void
 326           */
 327          void write_slave_06( uint16_t reg_addr, uint8_t reg_val_H, uint8_t reg_val_L)
 328          {
 329   1          uint8_t send_buf[8];
 330   1          uint16_t crc;
 331   1      
 332   1          while ( modbus.modbus_04_rcv_over == 0 );
 333   1      
 334   1          modbus.reg_addr_06 = reg_addr;
 335   1      
 336   1          send_buf[0] = SLAVE_ADDR;       //Addr
 337   1          send_buf[1] = FUN_06;           //Fun
 338   1      
 339   1          /*   Value_H  && Value_L    */
 340   1          send_buf[2] = modbus.reg_addr_06 >> 8;
 341   1          send_buf[3] = modbus.reg_addr_06;
 342   1          send_buf[4] = reg_val_H;
 343   1          send_buf[5] = reg_val_L;
 344   1      
 345   1          /*   crc    */
 346   1          crc = MODBUS_CRC16(send_buf,6);
 347   1          send_buf[6] = crc >> 8;
 348   1          send_buf[7] = crc;
 349   1      
 350   1          /*   发送，后使能接收    */
 351   1          memcpy(rs485.send_buf,send_buf,8);
 352   1      
 353   1          rs485.send_bytelength = 8;
 354   1          DR_485 = 1;                                 //485可以发送
 355   1          delay_ms(2);
 356   1          S4CON |= S4TI;                              //开始发送
 357   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
C51 COMPILER V9.60.7.0   MODBUS_RTU                                                        12/29/2025 21:49:48 PAGE 7   

   CODE SIZE        =   1113    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =     20      31
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
