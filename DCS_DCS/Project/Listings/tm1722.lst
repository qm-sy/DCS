C51 COMPILER V9.60.7.0   TM1722                                                            12/29/2025 21:49:48 PAGE 1   


C51 COMPILER V9.60.7.0, COMPILATION OF MODULE TM1722
OBJECT MODULE PLACED IN ..\Output\tm1722.obj
COMPILER INVOKED BY: D:\APP\KEIL\MDK\C51\BIN\C51.EXE ..\BSP\Src\tm1722.c LARGE OPTIMIZE(8,SPEED) BROWSE INCDIR(..\Driver
                    -;..\SYSTEM\Inc;..\BSP\Inc;..\Core\Inc;..\Emembed\Inc) DEBUG OBJECTEXTEND PRINT(.\Listings\tm1722.lst) TABS(2) OBJECT(..\
                    -Output\tm1722.obj)

line level    source

   1          #include "tm1722.h"
   2          
   3          LCD_INFO lcd_info;
   4          
   5          uint8_t value_03 = 0;  //该地址的值
   6          uint8_t value_06 = 0;
   7          uint8_t value_07 = 0;
   8          uint8_t value_0A = 0;
   9          uint8_t value_0B = 0;
  10          uint8_t value_0E = 0;
  11          uint8_t value_0F = 0; 
  12          
  13          uint8_t addr_tab[7] = { 0xc3,0xc6,0xc7,0xca,0xcb,0xce,0xcf};
  14          
  15          uint8_t num_tab[10] = {0xF5,0x05,0xD3,0x97,0x27,0xB6,0xF6,0x15,0xF7,0xB7};
  16                               /*  0    1    2    3    4    5    6    7    8    9  */
  17          
  18          void screen_init( void )
  19          {
  20   1          TM1722_WR = 1;            //端口配置初始化
  21   1          TM1722_CS = 1;
  22   1          TM1722_DATA = 1;
  23   1          TM1722_Write_Byte(0x00); //工作模式
  24   1          TM1722_WR = 1;
  25   1          TM1722_Write_Byte(0x44);   //固定地址模式
  26   1          TM1722_WR = 1;
  27   1          
  28   1          screen_clear();
  29   1          
  30   1          screen_display();
  31   1      }
  32           
  33          void lcd_info_init( void )
  34          {
  35   1          lcd_info.channel_num = 7;
  36   1          lcd_info.power_level = 50;
  37   1          lcd_info.fan_level = 3;
  38   1          lcd_info.sync_switch = 0;
  39   1          lcd_info.mode_num  = 1;
  40   1      
  41   1          lcd_info.sync_icon_ctrl_flag = 1;
  42   1          lcd_info.lcd_connect_flag = 0;
  43   1        lcd_info.alarm_temp_flick_flag = 1;
  44   1          lcd_info.Power_Swtich = 0;
  45   1      
  46   1          key.key_read_allow = 0;
  47   1      }
  48          
  49          void led_status_ctrl( uint8_t status ) 
  50          {
  51   1          switch (status)
  52   1          {
  53   2              case LED_OPEN:
C51 COMPILER V9.60.7.0   TM1722                                                            12/29/2025 21:49:48 PAGE 2   

  54   2              BL = 0;
  55   2              LED1 = LED2 = LED3 = LED4 = LED5 = LED6 = LED_ON;
  56   2              break;
  57   2          
  58   2              case LED_SLEEP:
  59   2              BL = 1;
  60   2              LED1 = LED_ON;
  61   2              LED2 = LED3 = LED4 = LED5 = LED6 = LED_OFF;
  62   2              break;
  63   2      
  64   2              default:
  65   2                  break;
  66   2          }
  67   1      }
  68          void screen_clear( void ) //清显示缓存
  69          {
  70   1          Celsius_dis(DIS_OFF);
  71   1          Percentage_dis(DIS_OFF);
  72   1          mode_dis(DIS_OFF);
  73   1          sync_dis(DIS_OFF);
  74   1          screen_write_val(addr_tab[ADDR_0B],0x00);
  75   1          screen_write_val(addr_tab[ADDR_0A],0X00);
  76   1          screen_write_val(addr_tab[ADDR_07],0X00);
  77   1          screen_write_val(addr_tab[ADDR_06],0X00);
  78   1          sun_dis(DIS_OFF);
  79   1          channel_dis(0);
  80   1          fan_leaf1_dis(DIS_OFF);
  81   1          fan_leaf2_dis(DIS_OFF);
  82   1          fan_center_dis(DIS_OFF);
  83   1          wind_dis(0);
  84   1      }
  85          
  86          void screen_display( void )  //显示开
  87          {
  88   1          TM1722_Write_Byte(0x93); 
  89   1          TM1722_WR = 1;
  90   1      }
  91          
  92          void screen_write_val(uint8_t addr,uint8_t dat)
  93          {
  94   1          TM1722_Write_Byte(addr); 
  95   1          TM1722_Write_Byte(dat); 
  96   1          TM1722_WR = 1;
  97   1      }
  98          
  99          void TM1722_Write_Byte(uint8_t dat)
 100          {
 101   1        uint8_t i;
 102   1               
 103   1        delay_us(50); //用于片选信号的延时
 104   1      
 105   1        TM1722_WR = 0;     //有效的片选信号
 106   1        for(i = 0;i < 8;i++)
 107   1        {
 108   2          TM1722_CS   = 0;
 109   2          TM1722_DATA = dat & 0x01;
 110   2          TM1722_CS   = 1;    //时钟上升沿，送入一位数据
 111   2          dat >>= 1;      
 112   2        }
 113   1      
 114   1        delay_us(50);   //用于片选信号的延时
 115   1      }
C51 COMPILER V9.60.7.0   TM1722                                                            12/29/2025 21:49:48 PAGE 3   

 116          
 117          void num_dis(uint8_t num)
 118          {
 119   1          uint8_t hundreds = num / 100;  // 获取百位数
 120   1          uint8_t tens = (num / 10) % 10;  // 获取十位数
 121   1          uint8_t ones = num % 10;  // 获取个位数
 122   1          
 123   1          value_0B &= 0x70;
 124   1          value_0A &= 0X00;
 125   1          value_07 &= 0X00;
 126   1          value_06 &= 0X08;
 127   1      
 128   1          if((num<10)&&(num>=0))
 129   1          {
 130   2              value_06 |= num_tab[ones]; 
 131   2      
 132   2              screen_write_val(addr_tab[ADDR_0B],0);
 133   2              screen_write_val(addr_tab[ADDR_0A],0);
 134   2              screen_write_val(addr_tab[ADDR_07],0);
 135   2      
 136   2              screen_write_val(addr_tab[ADDR_06],value_06);  
 137   2          }
 138   1          else if((num<100)&&(num>=10))
 139   1          {
 140   2              value_07 |= num_tab[tens];
 141   2              value_06 |= num_tab[ones]; 
 142   2      
 143   2              screen_write_val(addr_tab[ADDR_0B],0);
 144   2              screen_write_val(addr_tab[ADDR_0A],0);
 145   2      
 146   2              screen_write_val(addr_tab[ADDR_07],value_07);
 147   2              screen_write_val(addr_tab[ADDR_06],value_06);   
 148   2          }
 149   1          else
 150   1          {
 151   2              value_0B |= (num_tab[hundreds] >> 4);
 152   2              value_0A |= (num_tab[hundreds] & 0x0f);
 153   2              value_07 |= num_tab[tens];
 154   2              value_06 |= num_tab[ones]; 
 155   2      
 156   2              screen_write_val(addr_tab[ADDR_0B],value_0B);
 157   2              screen_write_val(addr_tab[ADDR_0A],value_0A);
 158   2              screen_write_val(addr_tab[ADDR_07],value_07);
 159   2              screen_write_val(addr_tab[ADDR_06],value_06);
 160   2          }
 161   1      }
 162          
 163          
 164          void wind_dis(uint8_t num)
 165          {
 166   1          value_0F &= 0x30;
 167   1          
 168   1          switch(num)
 169   1          {
 170   2              case 0: value_0F |= 0x00;   break;
 171   2              
 172   2              case 1: value_0F |= 0x40;   break;
 173   2              
 174   2              case 2: value_0F |= 0xc0;   break;
 175   2              
 176   2              case 3: value_0F |= 0xc8;   break;
 177   2              
C51 COMPILER V9.60.7.0   TM1722                                                            12/29/2025 21:49:48 PAGE 4   

 178   2              case 4: value_0F |= 0xcc;   break;
 179   2      
 180   2              case 5: value_0F |= 0xce;   break;
 181   2              
 182   2              case 6: value_0F |= 0xcf;   break;
 183   2              
 184   2              default:                    break;
 185   2          }
 186   1          
 187   1          screen_write_val(addr_tab[ADDR_0F],value_0F);
 188   1      }
 189          
 190          
 191          void channel_dis(uint8_t num)
 192          {
 193   1          value_0E &= 0x88;
 194   1          value_0B &= 0x0F;
 195   1          
 196   1          switch(num)
 197   1          {
 198   2              case 0: value_0E |= 0x00;   value_0B |= 0x00;   break;
 199   2      
 200   2              case 1: value_0E |= 0x04;   value_0B |= 0x40;   break;
 201   2              
 202   2              case 2: value_0E |= 0x02;   value_0B |= 0x20;   break;
 203   2              
 204   2              case 3: value_0E |= 0x01;   value_0B |= 0x10;   break;
 205   2              
 206   2              case 4: value_0E |= 0x06;   value_0B |= 0x60;   break;
 207   2              
 208   2              case 5: value_0E |= 0x05;   value_0B |= 0x50;   break;
 209   2              
 210   2              case 6: value_0E |= 0x03;   value_0B |= 0x30;   break;
 211   2              
 212   2              case 7: value_0E |= 0x07;   value_0B |= 0x70;   break;
 213   2              
 214   2              default:                                        break;
 215   2          }
 216   1          
 217   1          screen_write_val(addr_tab[ADDR_0E],value_0E);
 218   1          screen_write_val(addr_tab[ADDR_0B],value_0B);
 219   1      }
 220          
 221          
 222          void sun_dis(uint8_t on_off)
 223          {
 224   1          value_0E &= 0xf7;
 225   1      
 226   1          if( on_off == DIS_ON )
 227   1          {
 228   2              value_0E |= 0x08;   
 229   2          }
 230   1          screen_write_val(addr_tab[ADDR_0E],value_0E);
 231   1      }
 232          
 233          void sync_dis(uint8_t on_off)
 234          {
 235   1          value_03 &= 0xef;
 236   1      
 237   1          if( on_off == DIS_ON )
 238   1          {
 239   2              value_03 |= 0x10;   
C51 COMPILER V9.60.7.0   TM1722                                                            12/29/2025 21:49:48 PAGE 5   

 240   2          }
 241   1          screen_write_val(addr_tab[ADDR_03],value_03);
 242   1      }
 243          
 244          void alarm_dis(uint8_t on_off)
 245          {
 246   1          value_03 &= 0xdf;
 247   1      
 248   1          if( on_off == DIS_ON )
 249   1          {
 250   2              value_03 |= 0x20;   
 251   2          }
 252   1          screen_write_val(addr_tab[ADDR_03],value_03);
 253   1      }
 254          
 255          
 256          void Celsius_dis(uint8_t on_off)
 257          {
 258   1          value_03 &= 0xbf;
 259   1      
 260   1          if( on_off == DIS_ON )
 261   1          {
 262   2              value_03 |= 0x40;   
 263   2          }
 264   1          screen_write_val(addr_tab[ADDR_03],value_03);
 265   1      }
 266          
 267          void mode_dis(uint8_t on_off)
 268          {
 269   1          value_03 &= 0x7f;
 270   1      
 271   1          if( on_off == DIS_ON )
 272   1          {
 273   2              value_03 |= 0x80;   
 274   2          }
 275   1          screen_write_val(addr_tab[ADDR_03],value_03);
 276   1      }
 277          
 278          void Percentage_dis(uint8_t on_off)
 279          {
 280   1          value_06 &= 0xf7;
 281   1      
 282   1          if( on_off == DIS_ON )
 283   1          {
 284   2              value_06 |= 0x08;   
 285   2          }
 286   1          screen_write_val(addr_tab[ADDR_06],value_06);
 287   1      }
 288          
 289          
 290          void fan_center_dis(uint8_t on_off)
 291          {
 292   1          value_0F &= 0xdf;
 293   1      
 294   1          if( on_off == DIS_ON )
 295   1          {
 296   2              value_0F |= 0x20;   
 297   2          }
 298   1          screen_write_val(addr_tab[ADDR_0F],value_0F);
 299   1      }
 300          
 301          void fan_leaf1_dis(uint8_t on_off)
C51 COMPILER V9.60.7.0   TM1722                                                            12/29/2025 21:49:48 PAGE 6   

 302          {
 303   1          value_0E &= 0xef;
 304   1      
 305   1          if( on_off == DIS_ON )
 306   1          {
 307   2              value_0E |= 0x10;   
 308   2          }
 309   1          screen_write_val(addr_tab[ADDR_0E],value_0E);
 310   1      }
 311          
 312          void fan_leaf2_dis(uint8_t on_off)
 313          {
 314   1          value_0F &= 0xef;
 315   1          if( on_off == DIS_ON )
 316   1          {
 317   2              value_0F |= 0x10;   
 318   2          }
 319   1          screen_write_val(addr_tab[ADDR_0F],value_0F);
 320   1      }
 321          
 322          void fan_rotate_dis( uint8_t on_off )
 323          {
 324   1          fan_center_dis(DIS_ON);
 325   1          if( on_off == DIS_ON )
 326   1          {
 327   2              fan_leaf1_dis(lcd_info.sync_icon_ctrl_flag);
 328   2              fan_leaf2_dis(1 - lcd_info.sync_icon_ctrl_flag);
 329   2          }else
 330   1          {
 331   2              fan_leaf1_dis(DIS_ON);
 332   2              fan_leaf2_dis(DIS_OFF);
 333   2          }
 334   1      }
 335          
 336          void sync_icon_ctrl( void )
 337          {  
 338   1          if( lcd_info.sync_switch == 1 )
 339   1          {
 340   2              sync_dis(DIS_ON);
 341   2              if( lcd_info.signal_in == 1 )
 342   2              {
 343   3                  fan_rotate_dis(DIS_ON);
 344   3                  sun_dis(DIS_ON);
 345   3              }else
 346   2              {
 347   3                  fan_rotate_dis(DIS_OFF);
 348   3                  sun_dis(DIS_OFF);
 349   3              }
 350   2          }else
 351   1          {
 352   2              sync_dis(DIS_OFF);
 353   2              fan_rotate_dis(DIS_ON);
 354   2              sun_dis(DIS_ON);
 355   2          }
 356   1      }
 357          
 358          void screen_all_dis( void )
 359          {
 360   1          num_dis(lcd_info.power_level);
 361   1          wind_dis(lcd_info.fan_level);
 362   1          channel_dis(lcd_info.channel_num);
 363   1          sync_dis(lcd_info.sync_switch);
C51 COMPILER V9.60.7.0   TM1722                                                            12/29/2025 21:49:48 PAGE 7   

 364   1          sync_icon_ctrl();
 365   1          Percentage_dis(DIS_ON);
 366   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   1291    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =     37       7
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
